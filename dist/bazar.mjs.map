{"version":3,"file":"bazar.mjs","sources":["../src/bazar.mjs"],"sourcesContent":["/**\n *\n * CONFIG:\n * `config` object is the fundamental part of `bazar`.\n *  It stores the required connections to notify events to the correct elements\n *  and syncing state from every part of your application.\n *  The composing parts of `config` object are:\n * @param {string} id - REQUIRED. Must be unique. Defines, in the global store, the\n *  reference of the element when you register or notify.\n * @param {Function} sync - REQUIRED. Where you return which part of the local state you want\n *  to expose in the global store.\n * @param {array} interests - OPTIONAL. Array of watched IDs. When any of the ID notify,\n *  the `onNotify` function is invoked.\n * @param {Function} onNotify - OPTIONAL. Function invoked when any of the IDs specified in\n *  `interests` notify an update. It is invoked with (id, state) as arguments. So you can\n *  update your local state accordingly to avoid unnecessary re-renders.\n */\n\n// Looping through global store and invoking `onNotify` on every element that expressed an interest\n// on the ID that provoked a notification.\nconst notify = config => {\n  if (!config) throw new Error('config object is required to correctly notify a state update');\n  const { id, sync } = config;\n  const state = sync();\n\n  // preferring forEach over a more functional .filter followed by .map\n  // to keep O(n) time complexity when looping through a large store.\n  Object.keys(_BAZAR_STORE_)\n    .forEach(currentId => {\n      // Safely accessing store[id].interests.\n      // Looping through IDs to check all the components that expressed interest in\n      // the state change.\n      if ((_BAZAR_STORE_[currentId].interests || []).indexOf(id) !== -1) {\n        const current = _BAZAR_STORE_[currentId];\n\n        const { onNotify } = current;\n        if (!onNotify) throw new Error(`Attempted trigger of undefined onNotify function on ${currentId}`);\n\n        // Directly passing id and state at component level to avoid reading from global\n        onNotify(id, state);\n      }\n    });\n};\n\n// Registering a new component in the global store.\n// Make sure that `register` function runs only one time per registered component.\n// Otherwise an error of `Expected unique ID` will be thrown.\n// e.g. in a React component: Call `register` in the `constructor` method.\nconst register = config => {\n  const {\n    id,\n    sync,\n    onPoke,\n    onNotify,\n    interests,\n  } = config;\n\n  if (!id) throw new Error('Expected registrant to have non-null id value');\n  if (!sync) throw new Error('Expected registrant to have a sync function');\n  if (_BAZAR_STORE_.hasOwnProperty(id)) throw new Error('Expected unique id');\n\n  // Creating instance\n  _BAZAR_STORE_[id] = {\n    sync,\n    onPoke,\n    onNotify,\n    interests,\n  };\n};\n\n// The poke function let's you `poke` registered components with a valid `onPoke` function.\nconst poke = (id, arg) => {\n  const { onPoke } = (_BAZAR_STORE_[id] || {});\n  if (!onPoke) throw new Error('Attempted to poke component without an onPoke function');\n  onPoke(arg);\n};\n\n// Safely reading synced state drom one ID.\nconst getState = id => {\n  if (!_BAZAR_STORE_.hasOwnProperty(id)) throw new Error(`Attempted reading state from ${id}, non-registered component`);\n  return _BAZAR_STORE_[id].sync();\n};\n\n// Safely reading synced state drom multiple IDs.\n// Returns an handy object containing states grouped by ID.\nconst getStates = arr => {\n  const states = {};\n  arr.forEach(id => {\n    if (!_BAZAR_STORE_.hasOwnProperty(id)) throw new Error(`Attempted reading state from ${id}, non-registered component`);\n    states[id] = _BAZAR_STORE_[id].sync();\n  });\n  return states;\n};\n\n// Safely reading initial state. Returns undefined if no initial state is defined\n// for that specific ID.\nconst initState = id => (_BAZAR_STORE_.initial || {})[id];\n\n// Must run only one time\nconst initStore = (states = {}) => {\n  // Evaluating the global execution context.\n  // Useful because e.g. In Node.js you don't have access to a `window` object\n  // but you can create a global store through `global`.\n  const context = typeof global !== 'undefined'\n    ? global\n    : typeof self !== 'undefined'\n      ? self\n      : typeof window !== 'undefined'\n        ? window\n        : {};\n\n  context._BAZAR_STORE_ = {};\n\n  // setting up an initial store containing optional initial states\n  _BAZAR_STORE_.initial = {};\n  const initials = Object.keys(states);\n  if (initials.length > 0) initials.forEach(id => {\n    _BAZAR_STORE_.initial[id] = states[id];\n  });\n};\n\nexport {\n  initStore,\n  initState,\n  getState,\n  getStates,\n  register,\n  notify,\n  poke,\n};\n"],"names":["notify","config","Error","state","sync","Object","keys","_BAZAR_STORE_","forEach","currentId","interests","indexOf","id","onNotify","register","hasOwnProperty","onPoke","poke","arg","getState","getStates","arr","states","initState","initial","initStore","global","self","window","initials","length"],"mappings":"IAoBMA,WAASC,OACRA,EAAQ,MAAM,IAAIC,MAAM,2EAEvBC,GAAQC,YAIdC,OAAOC,KAAKC,eACTC,iBAAQC,OAIyD,KAA3DF,cAAcE,GAAWC,WAAa,IAAIC,QAAQC,GAAY,OACjDL,cAAcE,gBAGzBI,EAAU,MAAM,IAAIX,6DAA6DO,GAGtFI,EAASD,EAAIT,OASfW,WAAWb,iEASVW,EAAI,MAAM,IAAIV,MAAM,qDACpBE,EAAM,MAAM,IAAIF,MAAM,kDACvBK,cAAcQ,eAAeH,GAAK,MAAM,IAAIV,MAAM,sBAGtDK,cAAcK,GAAM,MAClBR,SACAY,WACAH,YACAH,IAKEO,WAAQL,EAAIM,UACIX,cAAcK,IAAO,eACpCI,EAAQ,MAAM,IAAId,MAAM,0DAC7Bc,EAAOE,IAIHC,WAAWP,OACVL,cAAcQ,eAAeH,GAAK,MAAM,IAAIV,sCAAsCU,uCAChFL,cAAcK,GAAIR,QAKrBgB,WAAYC,OACVC,EAAS,UACfD,EAAIb,iBAAQI,OACLL,cAAcQ,eAAeH,GAAK,MAAM,IAAIV,sCAAsCU,gCACvFU,EAAOV,GAAML,cAAcK,GAAIR,SAE1BkB,GAKHC,WAAYX,UAAOL,cAAciB,SAAW,IAAIZ,IAGhDa,WAAaH,kBAAS,KAIQ,oBAAXI,OACnBA,OACgB,oBAATC,KACLA,KACkB,oBAAXC,OACLA,OACA,IAEArB,cAAgB,GAGxBA,cAAciB,QAAU,OAClBK,EAAWxB,OAAOC,KAAKgB,GACzBO,EAASC,OAAS,GAAGD,EAASrB,iBAAQI,GACxCL,cAAciB,QAAQZ,GAAMU,EAAOV"}